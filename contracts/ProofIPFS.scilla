scilla_version 0

(* ProofIPFS Contract *)

import PairUtils ListUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library ProofIPFS

let one  = Uint128 1
let zero = Uint128 0

(* error codes library *)
let code_success        = Uint32 0
let code_item_not_found = Uint32 1
let code_not_authorized = Uint32 2
let code_invalid_params = Uint32 3
let code_itemid_exist   = Uint32 4

let fst_f = @fst (ByStr20) (BNum)
let snd_f = @snd (ByStr20) (BNum)

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract ProofIPFS
(owner: ByStr20)

(* ipfsInventory will store a Map of Items                          *)
(*     String  ipfs_cid (index)                                     *)
(*     ByStr20 registered account address                           *)
(*     BNum    block_number of registration                         *)

field ipfsInventory: Map String (Pair (ByStr20) (BNum))
                    = Emp String (Pair (ByStr20) (BNum))


(* ======== transitions ===============*)

(* @notice: Allows `_sender` to register ownership for a IPFS file *)
(* @dev   : No ccess controls - anybody is allowed to register     *)
(* @param : (String) ipfs_cid : IPFS CID (hash) of item (file)     *)
(* @return: (Uint32) code                                          *)

transition registerOwnership(ipfs_cid: String)

    registration <- ipfsInventory[ipfs_cid];
    match registration with
    | Some v =>
        e = {_eventname : "registerOwnership"; code : code_itemid_exist};
        event e
    | None =>
        (* Creating a new Item Model *)
		(* A new item model is a Pair of address (_sender) and block_number *)
		block_number <- & BLOCKNUMBER;
        new_item = Pair {(ByStr20) (BNum)} _sender block_number;

        (* Add the new item to the item_inventory Map, with ipfs_cid as the key   *)
        ipfsInventory[ipfs_cid] := new_item;

        e = {_eventname : "registerOwnership"; code : code_success};
        event e
    end
end


(* @notice: get registration info for IPFS file                            *)
(* @dev   : No ccess controls - anybody is allowed to get that information *)
(* @param : (String) ipfs_cid : IPFS CID (hash) of item (file)             *)
(* @return: Pair {(ByStr20) (BNum)} address block_number , (Uint32) code   *)

transition getRegistration(ipfs_cid: String)

    registration <- ipfsInventory[ipfs_cid];
    match registration with
    | Some v =>
        (* v contains (address, block_number) (Pair (ByStr20) (BNum)) *)
        e = {_eventname: "getRegistration_success"; code: code_success; msg: v};
        event e

    | None =>
        e = {_eventname: "getRegistration_item_not_found"; code: code_item_not_found};
        event e

    end
end


(* @notice: Delete a registration for a IPFS file                          *)
(* @dev   : only account address which registered ownership can delete     *)
(* @param : (String) ipfs_cid : IPFS CID (hash) of item (file)             *)
(* @return: (Uint32) code                                                  *)

transition deleteRegistration(ipfs_cid: String)

  registration <- ipfsInventory[ipfs_cid];
  match registration with
  | Some v =>
    reg_address  = fst_f v;
    has_registered = builtin eq reg_address _sender;

    match has_registered with
        | True =>
            delete ipfsInventory[ipfs_cid];
            e = {_eventname: "deleteRegistration"; code: code_success};
            event e
            
        | False =>
            e = {_eventname: "deleteRegistration"; code: code_not_authorized};
            event e
    end

  | None =>
    e = {_eventname: "deleteRegistration"; code: code_item_not_found};
    event e
  end

end
