scilla_version 0

(* ProofIPFS Contract *)

(***************************************************)
(*               Associated library                *)
(***************************************************)
library ProofIPFS

let one = Uint128 1
let zero = Uint128 0

let one_msg =
  fun (msg: Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* error codes library *)
let code_success        = Uint32 0
let code_item_not_found = Uint32 1
let code_not_authorized = Uint32 2
let code_invalid_params = Uint32 3
let code_itemid_exist   = Uint32 4

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract ProofIPFS
(owner: ByStr20)

(* ipfsInventory will store a Map of Items                          *)
(*     String  ipfs_cid (index)                                     *)
(*     ByStr20 owner address                                        *)
(*     BNum    block_number of registraton                          *)

field ipfsInventory: Map String (Pair (ByStr20) (BNum))
                    = Emp String (Pair (ByStr20) (BNum))


(* ======== transitions ===============*)

(* @notice: Allows `_sender` to register ownership for a IPFS file            *)
(* @dev   : No ccess controls - anybody is allowed to register                *)
(* @param : ipfs_cid : IPFS CID (hash) of item (file)                         *)

transition setOwnership(ipfs_cid: String)

    items <- ipfsInventory;
    (* new_item_id = let one = Uint32 1 in builtin add last_item_id one;*)

    itemExist = builtin contains items ipfs_cid;
    match itemExist with
    | True =>
        msg = {_tag: "";
                    _recipient: _sender;
                    _amount: Uint128 0;
                    code: code_itemid_exist};
        msgs = one_msg msg;
        send msgs
    | False =>
        (* Creating a new Item Model *)
				(* A new item model is a Pair of owner address (_sender) and block_number *)
				block_number <- & BLOCKNUMBER;
        new_item = Pair {(ByStr20) (BNum)} _sender block_number;

        (* Add the new item to the item_inventory Map, with ipfs_cid as the key   *)
        ipfsInventory[ipfs_cid] := new_item;

        msg = {_tag: "";
                _recipient: _sender;
                _amount: Uint128 0;
                code: code_success};

        msgs = one_msg msg;
        send msgs
    end
end

(* @notice: Allows a `_sender` to remove a item from the ipfsInventory *)
(* @dev   : Access control not yet implemented *)

transition deleteOwnership(ipfs_cid: String)

    items <- ipfsInventory;
    exist = builtin contains items ipfs_cid;
    match exist with
    | False =>
        (* Item ID is not found in the records. *)
        msg = {_tag: "";
                _recipient: _sender;
                _amount: Uint128 0;
                code: code_item_not_found};
        msgs = one_msg msg;
        send msgs
		| True =>
			(* TODO verify ownership *)
			(* Access control: Checking if sender is the owner of the Contract *)
			(* owner, block_number = ipfsInventory[ipfs_cid] *)
			(* is_authorized = builtin eq _sender owner;     *)
			delete ipfsInventory[ipfs_cid];
        msg = {_tag: "";
                _recipient: _sender;
                _amount: Uint128 0;
                code: code_success};
        msgs = one_msg msg;
        send msgs
    end


end
